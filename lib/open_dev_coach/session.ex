defmodule OpenDevCoach.Session do
  @moduledoc """
  Main session GenServer for managing OpenDevCoach application state.

  This module handles the core application logic and state management,
  serving as the central coordinator for all operations.
  """

  use GenServer
  require Logger
  alias OpenDevCoach.Tasks

  @doc """
  Starts the Session GenServer.
  """
  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @impl true
  def init(_opts) do
    Logger.info("OpenDevCoach Session started")
    {:ok, %{}}
  end

  # Task Management Functions

  @doc """
  Adds a new task to the system.
  """
  def add_task(description) do
    GenServer.call(__MODULE__, {:add_task, description})
  end

  @doc """
  Lists all tasks in the system.
  """
  def list_tasks do
    GenServer.call(__MODULE__, {:list_tasks})
  end

  @doc """
  Starts a task (marks as IN-PROGRESS).
  """
  def start_task(task_id) do
    GenServer.call(__MODULE__, {:start_task, task_id})
  end

  @doc """
  Completes a task (marks as COMPLETED).
  """
  def complete_task(task_id) do
    GenServer.call(__MODULE__, {:complete_task, task_id})
  end

  @doc """
  Removes a task from the system.
  """
  def remove_task(task_id) do
    GenServer.call(__MODULE__, {:remove_task, task_id})
  end

  @doc """
  Creates a backup of all tasks in markdown format.
  """
  def backup_tasks do
    GenServer.call(__MODULE__, {:backup_tasks})
  end

  @impl true
  def handle_call({:add_task, description}, _from, state) do
    case Tasks.add_task(description) do
      {:ok, task} ->
        message = "Task added: #{task.description} [ID: #{task.id}]"
        {:reply, {:ok, message}, state}

      {:error, reason} ->
        {:reply, {:error, "Failed to add task: #{reason}"}, state}
    end
  end

  def handle_call({:list_tasks}, _from, state) do
    tasks = Tasks.list_tasks()
    message = format_task_list(tasks)
    {:reply, {:ok, message}, state}
  end

  def handle_call({:start_task, task_id}, _from, state) do
    case Tasks.update_task_status(task_id, "IN-PROGRESS") do
      {:ok, _} ->
        message = "Task #{task_id} started and other tasks put on hold"
        {:reply, {:ok, message}, state}

      {:error, reason} ->
        {:reply, {:error, "Failed to start task: #{reason}"}, state}
    end
  end

  def handle_call({:complete_task, task_id}, _from, state) do
    case Tasks.update_task_status(task_id, "COMPLETED") do
      {:ok, _} ->
        message = "Task #{task_id} marked as completed"
        {:reply, {:ok, message}, state}

      {:error, reason} ->
        {:reply, {:error, "Failed to complete task: #{reason}"}, state}
    end
  end

  def handle_call({:remove_task, task_id}, _from, state) do
    case Tasks.remove_task(task_id) do
      {:ok, _} ->
        message = "Task #{task_id} removed"
        {:reply, {:ok, message}, state}

      {:error, reason} ->
        {:reply, {:error, "Failed to remove task: #{reason}"}, state}
    end
  end

  def handle_call({:backup_tasks}, _from, state) do
    case create_task_backup() do
      {:ok, filename} ->
        message = "Tasks backed up to #{filename}"
        {:reply, {:ok, message}, state}

      {:error, reason} ->
        {:reply, {:error, "Failed to backup tasks: #{reason}"}, state}
    end
  end

  def handle_call(_request, _from, state) do
    {:reply, {:ok, "Not implemented yet"}, state}
  end

  # Private Functions

  defp format_task_list(tasks) do
    case tasks do
      [] ->
        "No tasks found. Add one with `/task add <description>`"

      _ ->
        tasks
        |> Enum.with_index(1)
        |> Enum.map(fn {task, index} ->
          status_emoji = get_status_emoji(task.status)
          "  #{index}. #{status_emoji} #{task.description} [#{task.status}]"
        end)
        |> Enum.join("\n")
        |> then(&"Your Tasks:\n#{&1}")
    end
  end

  defp get_status_emoji(status) do
    case status do
      "PENDING" -> "â³"
      "IN-PROGRESS" -> "ğŸ”„"
      "ON-HOLD" -> "â¸ï¸"
      "COMPLETED" -> "âœ…"
      _ -> "â“"
    end
  end

  defp create_task_backup do
    tasks = Tasks.list_tasks()
    filename = "task_backup_#{Date.utc_today()}.md"

    content = """
    # Task Backup - #{Date.utc_today()}

    ## Active Tasks

    #{format_backup_tasks(tasks)}

    ---
    Generated by OpenDevCoach on #{DateTime.utc_now() |> DateTime.to_string()}
    """

    case File.write(filename, content) do
      :ok -> {:ok, filename}
      {:error, reason} -> {:error, reason}
    end
  end

  defp format_backup_tasks(tasks) do
    case tasks do
      [] ->
        "No tasks found."

      _ ->
        tasks
        |> Enum.map(fn task ->
          checkbox = if task.status == "COMPLETED", do: "- [x]", else: "- [ ]"
          "#{checkbox} #{task.description} [#{task.status}]"
        end)
        |> Enum.join("\n")
    end
  end
end
